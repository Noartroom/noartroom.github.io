---
/// PLAYCANVAS x WASM LIGHT ENGINE PROTOTYPE
---
<div class="viewer-wrapper">
  <canvas id="playcanvas-canvas"></canvas>
  <div class="controls">
    <p class="loading-text">Loading 3D Scene...</p>
    <button id="light-engine-toggle" class="engine-toggle-button" style="display: none;">Toggle Dynamic Lighting</button>
  </div>
</div>

<script>
/*   import * as pc from 'playcanvas/build/playcanvas.min.mjs';
 */
  declare const pc: any;
  (window as any).pc = pc;

  // --- Asset Configuration ---
  const ASSET_PATHS = {
    model: '/models/dezimiertt-glb-03.glb',
    darkModel: '/models/your-model-dark.glb', // dark version of the model
    aoMap: '/models/your-model-ao.jpg',
    orbitCamera: '/js/orbit-camera.js', // The script is now an asset managed by PlayCanvas
    interactionRaycast: '/js/interaction-raycast.js'
  };

  // --- State Management ---
  let lightEngineActive = false;
  let wasmModule: (WebAssembly.Instance & { exports: any }) | null = null;
  let animationFrameId: number | null = null;
  let mouseX = window.innerWidth / 2;
  let mouseY = window.innerHeight / 2;
  let pcApp: any = null;

  // --- WASM Helpers (with corrected, more robust loading) ---
  function unpack_coords(packed_val: bigint) {
    const x_bits = Number(packed_val >> 32n);
    const y_bits = Number(packed_val & 0xFFFFFFFFn);
    const buf = new ArrayBuffer(4);
    const f32 = new Float32Array(buf);
    const u32 = new Uint32Array(buf);
    u32[0] = x_bits; const x = f32[0];
    u32[0] = y_bits; const y = f32[0];
    return { x, y };
  }

  async function loadWasm() {
    if (wasmModule) return;
    try {
      // Use a more robust, two-step loading process for WASM
      const response = await fetch('/wasm/rust_light_web_engine.wasm');
      const buffer = await response.arrayBuffer();
      const { instance } = await WebAssembly.instantiate(buffer);
      wasmModule = instance;
      wasmModule.exports.init();
      console.log("WASM Light Engine is ready.");
    } catch (err) { console.error("Failed to load WASM module:", err); }
  }

  // --- Main Animation & Sync Loop ---
  function animate() {
    if (!lightEngineActive || !wasmModule || !pcApp) return;

    wasmModule.exports.update(mouseX, mouseY, window.innerWidth, window.innerHeight);

    const screenPosPacked = wasmModule.exports.get_2d_pos();
    const lightScreenPos = unpack_coords(screenPosPacked);
    // Manu: Update CSS variables for the light effect
    document.body.style.setProperty('--light-x', `${lightScreenPos.x}px`);
    document.body.style.setProperty('--light-y', `${lightScreenPos.y}px`);

    const pos3dPacked = wasmModule.exports.get_3d_pos();
    const light3dPos = unpack_coords(pos3dPacked);
    // Manu: Update the PlayCanvas light position vom dynamic light
    const dynamicLight = pcApp.root.findByName('MyDynamicLight');
    if (dynamicLight) {
        dynamicLight.setPosition(light3dPos.x ?? 0, 2.0, light3dPos.y ?? 0);
    }

    animationFrameId = requestAnimationFrame(animate);
  }

  // --- PlayCanvas Setup (Fully Corrected) ---
  async function initializeViewer() {
    /* const pc = await import('playcanvas'); */
    // Expose the 'pc' object globally so that external scripts like orbit-camera.js can access it.
    /* (window as any).pc = pc; */

      await new Promise<void>(resolve => {
      const interval = setInterval(() => {
        if ((window as any).Ammo) {
          clearInterval(interval);
          resolve();
        }
      }, 50);
    });
    
    const canvas = document.getElementById('playcanvas-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    // This provides a non-nullable reference ('app') that TypeScript's
    // control flow analysis can definitively track within this function's scope.
    const app = new pc.Application(canvas, {
      mouse: new pc.Mouse(document.body),
      touch: new pc.TouchDevice(document.body)
    });

    // Assign the guaranteed non-null instance to the outer-scope variable.
    pcApp = app;
    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
    app.setCanvasResolution(pc.RESOLUTION_AUTO);
    window.addEventListener('resize', () => app.resizeCanvas());
    
    // Load assets (Manu)
    const assets = [
        new pc.Asset('model', 'container', { url: ASSET_PATHS.model }),
        new pc.Asset('darkModel', 'container', { url: ASSET_PATHS.darkModel }),
        new pc.Asset('aoMap', 'texture', { url: ASSET_PATHS.aoMap }),
        new pc.Asset('orbitCamera', 'script', { url: ASSET_PATHS.orbitCamera }),
        new pc.Asset('interactionRaycast', 'script', { url: ASSET_PATHS.interactionRaycast }), // ADDED
    ];
    
    let loadedCount = 0;
    assets.forEach(asset => {
      console.log(`Queuing asset for loading: ${asset.name} (${asset.file.url})`);
      app.assets.add(asset);
      app.assets.load(asset);
            asset.on('load', () => {
                console.log(`✅ Successfully loaded: ${asset.name}`);
                loadedCount++;
                // Once all assets are loaded, build the scene
                if (loadedCount === assets.length) {
                    buildScene();
                }
            });

            asset.on('error', (err: Error) => {
              console.error(`❌ FAILED to load asset: ${asset.name} - URL: ${asset.file.url} - Error: ${err}`);
          });
        });
    /*
    let modelEntity: pc.Entity | null = null; // Declare modelEntity in the outer scope
 */

    // Configure scene Manu: HIer ist das meiste drin
    const buildScene = () => {
        // For more complex lighting setup, (needs some more setup config
        // app.scene.clusteredLightingEnabled = true;
        // app.scene.gammaCorrection = pc.GAMMA_SRGB;
        // app.scene.toneMapping = pc.TONEMAP_ACES;

        // SINGLE MODEL
        // const modelAsset = app.assets.find('model');

        // TWO MODELS (light and dark versions)
        const modelAsset = app.assets.find('model');
        const darkModelAsset = app.assets.find('darkModel');
        const aoMapAsset = app.assets.find('aoMap');

        // --- Instantiate Both Models ---
        const modelEntity = modelAsset.resource.instantiateRenderEntity();
        modelEntity.name = 'model';
        // app.root.addChild(modelEntity);

        const darkModelEntity = (darkModelAsset.resource).instantiateRenderEntity();
        darkModelEntity.name = 'darkModel';
        // app.root.addChild(darkModelEntity);

        // --- Instantiate single Model (commented out) ---
        /* const containerResource = modelAsset.resource as pc.ContainerResource;
        const modelEntity = containerResource.instantiateRenderEntity(); */ // Assign to outer-scope variable
        
        // const modelEntity = (modelAsset.resource as unknown as pc.ContainerResource).instantiateRenderEntity();
        // app.root.addChild(modelEntity as unknown as pc.GraphNode);

        // Add physics components for raycasting (commented out)
        [modelEntity, darkModelEntity].forEach(model => {
          const embeddedLights = model.findComponents('light');
          if (embeddedLights.length > 0) {
              console.warn(`Found and destroyed ${embeddedLights.length} light(s) embedded in model: ${model.name}`);
              embeddedLights.forEach((light: pc.LightComponent) => {
                  (light as any).entity.destroy();
              });
          }
          
          app.root.addChild(model);
          
          // modelEntity.addComponent('rigidbody', { type: 'static' }); // check if helps TODO
          // modelEntity.addComponent('collision', { type: 'mesh' }); // for different models, adjust TODO
          model.addComponent('rigidbody', { type: 'static' }); // check if helps TODO
          model.addComponent('collision', { type: 'mesh' }); // for different models, adjust TODO
        
          // Search the entire model hierarchy to find the render component
          const renderComponent = model.findComponent('render');

          // Now, check if we found a render component and it has a material
          if (renderComponent && renderComponent.meshInstances[0]) {
            const material = renderComponent.meshInstances[0].material;
            //material.diffuse = new pc.Color(1, 1, 1);  // Set base color to white. TODO: double-check color
            material.diffuse = new pc.Color(1, 1, 1);

                  // Set a unique glow color for each model
                  // (Commented out because no effect was visible)
                  /* if (model.name === 'model') {
                      material.emissive = new pc.Color(1, 1, 1); // White
                  } else {
                      material.emissive = new pc.Color(1, 0, 1); // Magenta
                  } */

                  // Apply separate AO map
                  if (aoMapAsset?.resource) {
                      material.aoMap = aoMapAsset.resource as pc.Texture;
                  }
                  
                  // Push the changes to the GPU
                  material.update();
              
          }
        });

        // --- Set Initial Visibility ---
        const isInitiallyDark = document.documentElement.classList.contains('dark');
        modelEntity.enabled = !isInitiallyDark;
        darkModelEntity.enabled = isInitiallyDark;

        // The entity that the camera will focus on
        const focusEntity = isInitiallyDark ? darkModelEntity : modelEntity;

        // Create camera
        const camera = new pc.Entity('camera');
        camera.addComponent('camera', {
            clearColor: new pc.Color(0.12, 0.12, 0.12)
           /*  farClip: 100, */
        });

        camera.addComponent('script');
        

        camera.script.create('orbitCamera', { attributes: {
            inertiaFactor: 0.1,
            focusEntity: focusEntity, // Initially focus on the scene origin . try app.root
            distance: 8,      // Start 8 units away from the model
            // maxDistance: 15,       // Set a max zoom out distance
            pitch: -20,       // Look slightly down at it
           //  yaw: 10,        // Look slightly to the right   
        } });

        camera.script.create('orbitCameraInputMouse');
        camera.script.create('orbitCameraInputTouch');
    

        if (camera.script) {
            camera.script.create('interactionRaycast', {
                attributes: { cameraEntity: camera }
            });
        }

        app.root.addChild(camera);

        // Create lights Manu: die lights
        const ambientLight = new pc.Entity('ambientLight');
        ambientLight.addComponent('light', { type: 'ambient', color: new pc.Color(0.4, 0.4, 0.4) }); // TODO : play with this color
        app.root.addChild(ambientLight);

        const staticLight = new pc.Entity('staticLight');
        staticLight.addComponent('light', {
            type: 'directional',
            intensity: 1.5,
            castShadows: true,
            shadowResolution: 1024,
           /*  shadowBias: 0.2,
            normalOffsetBias: 0.05, */
        });
        staticLight.setEulerAngles(45, 30, 0);
        app.root.addChild(staticLight);

        // TODO: Check: seems to have no effect
        const dynamicLight = new pc.Entity('MyDynamicLight');
        dynamicLight.addComponent('light', {
            type: 'point',
            intensity: 1.5,
            range: 30,
            color: new pc.Color(1, 0.7, 0.4),
        });
        app.root.addChild(dynamicLight);

        

    // Load the camera script FIRST, as it's a dependency for scene interaction.
    /* app.assets.add(assets.orbitCamera);
    app.assets.load(assets.orbitCamera); */
    
    // Once the camera script is loaded, attach it and then load remaining assets.
    /* app.assets.on(`load:${assets.orbitCamera.id}`, () => {
        camera.addComponent('script');
        if (camera.script) {
          camera.script.create('orbitCamera', { attributes: { inertiaFactor: 0.05 } });
        }

        app.assets.add(assets.model);
        app.assets.add(assets.aoMap);
        app.assets.load(assets.model);
        app.assets.load(assets.aoMap);
    }); */
    
    // app.assets.on(`load:${assets.model.id}`, () => {

// Instantiate model
   //  });
        // Add all remaining entities to the scene
       /*  app.root.addChild(camera);
        app.root.addChild(ambientLight);
        app.root.addChild(staticLight);
        app.root.addChild(dynamicLight);

        if (camera.script && modelEntity) { // Ensure modelEntity is not null
          (camera.script as any).orbitCamera.focusEntity = modelEntity;
        }
        */

        // Update UI
        const loadingText = document.querySelector('.loading-text') as HTMLElement;
        if(loadingText) loadingText.style.display = 'none';

        const toggleButton = document.getElementById('light-engine-toggle') as HTMLElement;
        if(toggleButton) toggleButton.style.display = 'block';

        // Add the lights AFTER the first frame has started.
        // This avoids the initialization race condition.
       /*  setTimeout(() => {
            app.root.addChild(ambientLight);
            app.root.addChild(staticLight);
            app.root.addChild(dynamicLight); // The dynamic light is optional
        }, 100); */ // 100ms delay is more than enough
         // Start the engine
        app.start();
    };
  }
  // --- Main Execution ---
  document.addEventListener('DOMContentLoaded', () => {
    initializeViewer();

    const themeToggleButton = document.getElementById('themeToggle'); // Assumes your button has id="themeToggle"
    if (themeToggleButton) {
      themeToggleButton.addEventListener('click', () => {
        // Use a small delay to ensure the <html> class has been updated before we check it
        setTimeout(handleThemeChange, 50);
      });
    }

    const toggleButton = document.getElementById('light-engine-toggle');
    toggleButton?.addEventListener('click', () => {
      lightEngineActive = !lightEngineActive;
      document.body.classList.toggle('light-engine-active', lightEngineActive);
      if (lightEngineActive) {
        if (!wasmModule) { loadWasm().then(animate); } else { animate(); }
      } else {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    window.addEventListener('mousemove', (event) => { 
      mouseX = event.clientX; 
      mouseY = event.clientY; 
    });

    if ('requestIdleCallback' in window) {
      requestIdleCallback(loadWasm);
    } else {
      setTimeout(loadWasm, 2000);
    }
  });

  function handleThemeChange() {
    if (!pcApp) return;

    const isDark = document.documentElement.classList.contains('dark');

    const model = pcApp.root.findByName('model');
    const darkModel = pcApp.root.findByName('darkModel');
    const cameraEntity = pcApp.root.findByName('camera');

    if (model && darkModel && cameraEntity) {
      model.enabled = !isDark;
      darkModel.enabled = isDark;

      // Update the camera's focus to the newly visible model
      const focusEntity = isDark ? darkModel : model;
      (cameraEntity.script as any).orbitCamera.focusEntity = focusEntity;
    }
  }
</script>

<style>
  .viewer-wrapper {
    position: relative;
    width: 100%;
    height: 600px;
    background-color: #1f1f1f;
  }
  #playcanvas-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  .controls {
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 10;
    color: white;
  }
  .engine-toggle-button {
    cursor: pointer;
    padding: 8px 16px;
    background-color: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    border-radius: 4px;
    transition: background-color 0.2s;
  }
  .engine-toggle-button:hover {
    background-color: rgba(0, 0, 0, 0.7);
  }
</style>