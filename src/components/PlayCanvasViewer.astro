---
/// PLAYCANVAS x WASM LIGHT ENGINE PROTOTYPE
---
<div class="viewer-wrapper">
  <canvas id="playcanvas-canvas"></canvas>
  <div class="controls">
    <p class="loading-text">Loading 3D Scene...</p>
    <button id="light-engine-toggle" class="engine-toggle-button" style="display: none;">Toggle Dynamic Lighting</button>
  </div>
</div>

<script>

  // --- Asset Configuration ---
  const ASSET_PATHS = {
    model: '/models/your-model.glb',
    aoMap: '/models/your-model-ao.jpg',
    orbitCamera: '/js/orbit-camera.js', // The script is now an asset managed by PlayCanvas
  };

  // --- State Management ---
  let lightEngineActive = false;
  let wasmModule: (WebAssembly.Instance & { exports: any }) | null = null;
  let animationFrameId: number | null = null;
  let mouseX = window.innerWidth / 2;
  let mouseY = window.innerHeight / 2;
  let pcApp: any = null;

  // --- WASM Helpers (with corrected, more robust loading) ---
  function unpack_coords(packed_val: bigint) {
    const x_bits = Number(packed_val >> 32n);
    const y_bits = Number(packed_val & 0xFFFFFFFFn);
    const buf = new ArrayBuffer(4);
    const f32 = new Float32Array(buf);
    const u32 = new Uint32Array(buf);
    u32[0] = x_bits; const x = f32[0];
    u32[0] = y_bits; const y = f32[0];
    return { x, y };
  }

  async function loadWasm() {
    if (wasmModule) return;
    try {
      // Use a more robust, two-step loading process for WASM
      const response = await fetch('/wasm/rust_light_web_engine.wasm');
      const buffer = await response.arrayBuffer();
      const { instance } = await WebAssembly.instantiate(buffer);
      wasmModule = instance;
      wasmModule.exports.init();
      console.log("WASM Light Engine is ready.");
    } catch (err) { console.error("Failed to load WASM module:", err); }
  }

  // --- Main Animation & Sync Loop ---
  function animate() {
    if (!lightEngineActive || !wasmModule || !pcApp) return;

    wasmModule.exports.update(mouseX, mouseY, window.innerWidth, window.innerHeight);

    const screenPosPacked = wasmModule.exports.get_2d_pos();
    const lightScreenPos = unpack_coords(screenPosPacked);
    document.body.style.setProperty('--light-x', `${lightScreenPos.x}px`);
    document.body.style.setProperty('--light-y', `${lightScreenPos.y}px`);

    const pos3dPacked = wasmModule.exports.get_3d_pos();
    const light3dPos = unpack_coords(pos3dPacked);
    const dynamicLight = pcApp.root.findByName('MyDynamicLight');
    if (dynamicLight) {
        dynamicLight.setPosition(light3dPos.x ?? 0, 2.0, light3dPos.y ?? 0);
    }

    animationFrameId = requestAnimationFrame(animate);
  }

  // --- PlayCanvas Setup (Fully Corrected) ---
  async function initializeViewer() {
    const pc = await import('playcanvas');
    // Expose the 'pc' object globally so that external scripts like orbit-camera.js can access it.
    (window as any).pc = pc;
    
    const canvas = document.getElementById('playcanvas-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    // This provides a non-nullable reference ('app') that TypeScript's
    // control flow analysis can definitively track within this function's scope.
    const app = new pc.Application(canvas, {
      mouse: new pc.Mouse(document.body),
      touch: new pc.TouchDevice(document.body)
    });

    // Assign the guaranteed non-null instance to the outer-scope variable.
    pcApp = app;
    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
    app.setCanvasResolution(pc.RESOLUTION_AUTO);
    window.addEventListener('resize', () => app.resizeCanvas());
    
    const assets = {
      model: new pc.Asset('model', 'container', { url: ASSET_PATHS.model }),
      aoMap: new pc.Asset('aoMap', 'texture', { url: ASSET_PATHS.aoMap }),
      orbitCamera: new pc.Asset('orbit-camera', 'script', { url: ASSET_PATHS.orbitCamera }),
    };
    
    Object.values(assets).forEach(asset => app.assets.add(asset));
    
    let modelEntity: pc.Entity | null = null; // Declare modelEntity in the outer scope

    app.preload(() => {
        // Configure scene
        app.scene.clusteredLightingEnabled = true;
        // app.scene.gammaCorrection = pc.GAMMA_SRGB;
        // app.scene.toneMapping = pc.TONEMAP_ACES;

        // Create camera
        

        const camera = new pc.Entity('camera');
        camera.addComponent('camera', {
            clearColor: new pc.Color(0.12, 0.12, 0.12),
            farClip: 100,
        });

        camera.addComponent('script');
        
        // INTERACTIVITY
        if (camera.script) {
            camera.script.create('orbitCamera', { attributes: {
                inertiaFactor: 0.05,
                focusEntity: app.root, // Initially focus on the scene origin
                distanceMax: 20,       // Set a max zoom out distance
            } });
        }
        
        // INTERACTIVITY FIX END

        camera.setPosition(0, 1, 5);

        

        // Create lights
        const ambientLight = new pc.Entity('ambientLight');
        ambientLight.addComponent('light', { type: 'ambient', color: new pc.Color(0.3, 0.3, 0.3) });

        const staticLight = new pc.Entity('staticLight');
        staticLight.addComponent('light', {
            type: 'directional',
            intensity: 1.2,
            castShadows: true,
            shadowResolution: 2048,
            shadowBias: 0.2,
            normalOffsetBias: 0.05,
        });
        staticLight.setEulerAngles(45, 30, 0);

        const dynamicLight = new pc.Entity('MyDynamicLight');
        dynamicLight.addComponent('light', {
            type: 'point',
            intensity: 1.5,
            range: 30,
            color: new pc.Color(1, 0.7, 0.4),
        });

        

          // Load the camera script FIRST, as it's a dependency for scene interaction.
    app.assets.add(assets.orbitCamera);
    app.assets.load(assets.orbitCamera);
    
    // Once the camera script is loaded, attach it and then load remaining assets.
    app.assets.on(`load:${assets.orbitCamera.id}`, () => {
        camera.addComponent('script');
        if (camera.script) {
          camera.script.create('orbitCamera', { attributes: { inertiaFactor: 0.05 } });
        }

        app.assets.add(assets.model);
        app.assets.add(assets.aoMap);
        app.assets.load(assets.model);
        app.assets.load(assets.aoMap);
    });
    
    app.assets.on(`load:${assets.model.id}`, () => {

// Instantiate model

        const containerResource = assets.model.resource as pc.ContainerResource;
        modelEntity = containerResource.instantiateRenderEntity(); // Assign to outer-scope variable
        app.root.addChild(modelEntity);

        if (modelEntity.render?.meshInstances[0] && assets.aoMap.resource) {
            const material = modelEntity.render.meshInstances[0].material as pc.StandardMaterial;
            material.aoMap = assets.aoMap.resource as pc.Texture;
            material.update();
        }
        
        

        
    });
        

        // Add all remaining entities to the scene
        app.root.addChild(camera);
        app.root.addChild(ambientLight);
        app.root.addChild(staticLight);
        app.root.addChild(dynamicLight);

        if (camera.script && modelEntity) { // Ensure modelEntity is not null
          (camera.script as any).orbitCamera.focusEntity = modelEntity;
        }
       

        // Update UI
        const loadingText = document.querySelector('.loading-text') as HTMLElement;
        if(loadingText) loadingText.style.display = 'none';

        const toggleButton = document.getElementById('light-engine-toggle') as HTMLElement;
        if(toggleButton) toggleButton.style.display = 'block';

         // Start the engine
        app.start();
    });
  }
  // --- Main Execution ---
  document.addEventListener('DOMContentLoaded', () => {
    initializeViewer();

    const toggleButton = document.getElementById('light-engine-toggle');
    toggleButton?.addEventListener('click', () => {
      lightEngineActive = !lightEngineActive;
      document.body.classList.toggle('light-engine-active', lightEngineActive);
      if (lightEngineActive) {
        if (!wasmModule) { loadWasm().then(animate); } else { animate(); }
      } else {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    });

    window.addEventListener('mousemove', (event) => { 
      mouseX = event.clientX; 
      mouseY = event.clientY; 
    });

    if ('requestIdleCallback' in window) {
      requestIdleCallback(loadWasm);
    } else {
      setTimeout(loadWasm, 2000);
    }
  });
</script>

<style>
  .viewer-wrapper {
    position: relative;
    width: 100%;
    height: 600px;
    background-color: #1f1f1f;
  }
  #playcanvas-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  .controls {
    position: absolute;
    top: 16px;
    left: 16px;
    z-index: 10;
    color: white;
  }
  .engine-toggle-button {
    cursor: pointer;
    padding: 8px 16px;
    background-color: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: white;
    border-radius: 4px;
    transition: background-color 0.2s;
  }
  .engine-toggle-button:hover {
    background-color: rgba(0, 0, 0, 0.7);
  }
</style>