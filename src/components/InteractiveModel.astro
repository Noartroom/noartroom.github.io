---
export interface Props {
  lightSrc: string;
  darkSrc: string;
  poster?: string;
  alt: string;
}
const { lightSrc, darkSrc, alt, poster } = Astro.props;
---
<!-- other attributes: poster = webp file  
 poster="/images/m1frameKopieHEIF.heic"
 style="background-color: transparent;"
         interaction-prompt="auto"
        interaction-prompt-threshold="1000"
 ar  ar-status="not-presenting" auto-rotate orbit-sensitivity="number"with-credentials="true" -->

<div class="model-wrapper" data-light-src={lightSrc} data-dark-src={darkSrc}>
    <model-viewer
        class="viewer"
        alt={alt}
        shadow-intensity="1"
        camera-controls
        camera-orbit="45deg 55deg 10m"
        reveal="manual"
        exposure="1"
    >   
        <div class="progress-bar hide" slot="progress-bar" aria-label="Loading model: 0% complete" aria-valuenow="0">
            <div class="update-bar"></div>
        </div>

        <button 
            slot="poster" 
            class="poster-button" 
            style={poster ? `--poster-bg: url(${poster})` : ''}
            ><span class="button-text">Load 3D Model</span>
        </button>
        <div class="error-message hide" slot="poster">
          <p>Sorry, 3D model could not be loaded.</p>
        </div>
    </model-viewer>
</div>

<script>
import '@google/model-viewer';
import type { ModelViewerElement } from '@google/model-viewer';

/**
 * Pre-fetches a model URL so it's stored in the browser's cache
 * for instant loading later.
 * @param {string} url The URL of the model to preload.
 */
function preloadModel(url: string) {
  // DEBUG: Log which specific URL is being fetched for caching.
  console.log(`[Preload] ðŸš€ Fetching to cache: ${url}`);
  fetch(url);
}

/**
 * Finds all model components on the page and preloads their assets.
 */
function preloadAllModels() {
  const modelWrappers = document.querySelectorAll('.model-wrapper');
  // DEBUG: Log how many model components were found.
  console.log(`[Preload] Found ${modelWrappers.length} model(s) to check for preloading.`);

  modelWrappers.forEach((modelWrapper, index) => {
    const { lightSrc, darkSrc } = (modelWrapper as HTMLElement).dataset;
    // DEBUG: Log the data attributes found for each specific model.
    console.log(`[Preload] Checking Model #${index + 1}:`, { lightSrc, darkSrc });

    if (lightSrc) {
      preloadModel(lightSrc);
    }

    // Preload the dark model only if it's different from the light one.
    if (darkSrc && darkSrc !== lightSrc) {
      preloadModel(darkSrc);
    }
  });
}

function initInteractiveModel(modelWrapper: HTMLElement) {
    // We select the component's root element
    if ((modelWrapper as any)._modelInitialized) return;
    (modelWrapper as any)._modelInitialized = true;

    const modelViewer = modelWrapper.querySelector('.viewer') as ModelViewerElement;
    if (!modelViewer) return;

    const progressBar = modelWrapper.querySelector('.progress-bar') as HTMLElement;
    const updateBar = modelWrapper.querySelector('.update-bar') as HTMLElement;
    const posterButton = modelWrapper.querySelector('.poster-button') as HTMLElement;
    const errorMessage = modelWrapper.querySelector('.error-message') as HTMLElement;

    // --- Event Listeners ---
    posterButton?.addEventListener('click', () => {
        // 1. Determine the correct src based on the current theme.
        const isDark = document.documentElement.classList.contains('dark');
        const lightSrc = modelWrapper.dataset.lightSrc;
        const darkSrc = modelWrapper.dataset.darkSrc;
        
        if (lightSrc && darkSrc) {
            // 2. Set the 'src' attribute now, on the ready component.
            modelViewer.src = isDark ? darkSrc : lightSrc;
        }

        // 3. Now that the src is set, dismiss the poster to start loading.
        modelViewer.dismissPoster();
        progressBar?.classList.remove('hide');
        
        // 4. Add the 'load' listener for post-load actions.
        modelViewer.addEventListener('load', () => {
            updateModelThemes();
            startOrbitAnimation(modelViewer);
        }, { once: true });
    });

    modelViewer.addEventListener('progress', (event) => {
        const progress = (event as unknown as CustomEvent).detail.totalProgress;
        const percent = Math.round(progress * 100);
        if (progressBar && updateBar) {
            progressBar.setAttribute('aria-valuenow', `${percent}`);
            updateBar.style.width = `${percent}%`;
        }
        if (progress === 1) {
            setTimeout(() => progressBar?.classList.add('hide'), 500);
        }
    });

    modelViewer.addEventListener('error', (event) => {
        console.error('Model Viewer Error:', (event as unknown as CustomEvent).detail);
        errorMessage?.classList.remove('hide');
        posterButton?.classList.add('hide'); // Hide the load button on error
    });
}

// --- Initial camera animation ---
function startOrbitAnimation(modelViewer: ModelViewerElement) {
   // The initial state is already set by the HTML. We just define a target.
    const targetOrbit = "-45deg 75deg 8m";
    let animationTimeout: ReturnType<typeof setTimeout>;

    // Plan the animation for 2 seconds in the future.
    animationTimeout = setTimeout(() => {
        modelViewer.cameraOrbit = targetOrbit;
    }, 3000);

    // If the user interacts before the 2 seconds are up, cancel the animation.
    modelViewer.addEventListener('pointerdown', () => {
        clearTimeout(animationTimeout);
    }, { once: true });
}

async function updateModelThemes() {
    const modelWrapper = document.querySelector('.model-wrapper') as HTMLElement;
    if (!modelWrapper) return;

    const oldViewer = modelWrapper.querySelector('model-viewer') as ModelViewerElement;
    const { lightSrc, darkSrc } = modelWrapper.dataset;
    if (!oldViewer || !lightSrc || !darkSrc) return;

    if (!oldViewer.src) {
        console.log('[Theme Change] ðŸ§ Model not loaded yet. Aborting theme swap for model.');
        return;
    }
    
    const isDark = document.documentElement.classList.contains('dark');
    const newSrc = isDark ? darkSrc : lightSrc;
    
    if (oldViewer.src && oldViewer.src.endsWith(newSrc)) {
        console.log(`[Theme Change] ðŸ§ Model src is already correct. No change needed.`);
        return;
    }

    console.log(`[Theme Change] ðŸ’¥ Recreating model viewer to load: ${newSrc}`);

    const newViewer = document.createElement('model-viewer');

    // --- NEW FIX: Explicitly add the 'viewer' class ---
    newViewer.classList.add('viewer');

    for (const attr of oldViewer.attributes) {
        // We already set the class, so we can skip it in the loop
        if (attr.name === 'class') continue;
        newViewer.setAttribute(attr.name, attr.value);
    }
    
    newViewer.src = newSrc;

    while (oldViewer.firstChild) {
        newViewer.appendChild(oldViewer.firstChild);
    }

    const progressBar = modelWrapper.querySelector('.progress-bar') as HTMLElement;
    const updateBar = modelWrapper.querySelector('.update-bar') as HTMLElement;
    
    newViewer.addEventListener('progress', (event) => {
        const progress = (event as unknown as CustomEvent).detail.totalProgress;
        const percent = Math.round(progress * 100);
        if (progressBar && updateBar) {
            progressBar.classList.remove('hide');
            progressBar.setAttribute('aria-valuenow', `${percent}`);
            updateBar.style.width = `${percent}%`;
        }
        if (progress === 1) {
           setTimeout(() => progressBar?.classList.add('hide'), 500);
        }
    });

    newViewer.addEventListener('load', () => {
        startOrbitAnimation(newViewer);
    }, { once: true });

    // --- NEW DEBUG LOG ---
    console.log('[Theme Change] ðŸ”Ž Inspect the new viewer element about to be added:', newViewer);

    if (oldViewer.parentNode) {
      oldViewer.parentNode.replaceChild(newViewer, oldViewer);
    }

    newViewer.dismissPoster();
}

// async function updateModelThemes() {
   /* const modelWrapper = document.querySelector('.model-wrapper') as HTMLElement;
    if (!modelWrapper) return;

    const modelViewer = modelWrapper.querySelector('.viewer') as ModelViewerElement;
    const { lightSrc, darkSrc } = modelWrapper.dataset;
    if (!modelViewer || !lightSrc || !darkSrc) return;

    const isDark = document.documentElement.classList.contains('dark');
    const newSrc = isDark ? darkSrc : lightSrc;

    // Only swap if the src is actually different
    if (modelViewer.src === newSrc) return;

    // --- VIEW TRANSITION LOGIC ---
    // Check if the browser supports View Transitions
    if (!document.startViewTransition) {
        modelViewer.src = newSrc; // Fallback for older browsers
        return;
    }

    // Use a View Transition to create a smooth cross-fade
    document.startViewTransition(() => {
        modelViewer.src = newSrc;
    });
    await modelViewer.updateComplete; // Wait for the model to finish updating */
/* 
    const modelWrapper = document.querySelector('.model-wrapper') as HTMLElement;
    if (!modelWrapper) return;

    const modelViewer = modelWrapper.querySelector('.viewer') as ModelViewerElement;
    const { lightSrc, darkSrc } = modelWrapper.dataset;
    if (!modelViewer || !lightSrc || !darkSrc) return;

     if (!modelViewer.src) {
        console.log('[Theme Change] ðŸ§ Model not loaded yet. Aborting theme swap for model.');
        return;
    }

    const isDark = document.documentElement.classList.contains('dark');
    const newSrc = isDark ? darkSrc : lightSrc;

    // This guard clause now prevents the error.
    if (modelViewer.src && modelViewer.src.endsWith(newSrc)) {
        console.log(`[Theme Change] ðŸ§ Model src is already correct. No change needed.`);
        return;
    }

    // --- VIEW TRANSITION LOGIC TRIED AND REMOVED ---
    if (!document.startViewTransition) {
        console.log(`[Theme Change] ðŸŽ¨ Swapping model src to: ${newSrc}`);
        modelViewer.src = newSrc;
        return;
    }

    document.startViewTransition(() => {
        console.log(`[Theme Change] ðŸŽ¨ Swapping model src with View Transition to: ${newSrc}`);
        modelViewer.src = newSrc;
    });
} */

// --- Main Execution ---
function setup() {
    // Find and initialize all instances of the component on the page.
    document.querySelectorAll('.model-wrapper').forEach(modelWrapper => {
        initInteractiveModel(modelWrapper as HTMLElement);
    });
     // Find your theme toggle button by its ID.
    const themeToggleButton = document.getElementById('themeToggle');
    // If the button exists and we haven't already attached a listener...
    if (themeToggleButton && !(themeToggleButton as any)._modelThemeListenerAttached) {
        
        themeToggleButton.addEventListener('click', () => {
            // We use a tiny delay. This is a standard and reliable technique to ensure
            // the ThemeIcon script has finished toggling the .dark class
            // *before* our updateModelThemes function runs to check for it.
             setTimeout(updateModelThemes, 50);
        });

        // Mark the button so we don't attach this listener multiple times.
        (themeToggleButton as any)._modelThemeListenerAttached = true;
    }
}

// Run setup on initial load and after every page swap for View Transitions.
document.addEventListener('DOMContentLoaded', () => {
  // Run the standard setup to make the page interactive.
  setup();

  // Now, use idle time to preload assets for the next interaction.
  if ('requestIdleCallback' in window) {
    window.requestIdleCallback(preloadAllModels);
  } else {
    // Fallback for older browsers that don't support requestIdleCallback.
    // Preload after 2 seconds to avoid interfering with the main thread. TODO: adjust if needed
    setTimeout(preloadAllModels, 2000);
  }
});
document.addEventListener('astro:after-swap', setup);
</script>

<style>
  /* Scoped styles for this component only */

  /* --- Optional CSS for View Transitions --- */
  /* This makes the cross-fade animation a bit slower and smoother */
  ::view-transition-old(root),
  ::view-transition-new(root) {
    animation-duration: 0.5s;
  }

  .model-wrapper {
    width: 100%;
    max-width: 720px;
    height: 600px;
    margin: auto;
    display: flex;
    justify-content: center;
    align-items: center;
    /* The wrapper is now always transparent */
    background-color: transparent;
  }
  
  model-viewer {
    width: 100%;
    height: 100%;
    --mv-progress-bar-color: rgba(0, 0, 0, 0.5);;
  }

  :global(html.dark) model-viewer {
    --mv-progress-bar-color: rgba(0, 0, 0, 0.5);;
  }

  .poster-button {
    background-image: var(--poster-bg);
    background-color: transparent;
    /* background-color: #e0e0e0; */ /* Fallback color if no image */ /*  TODO remove */
    /* background-size: cover; */ /*  TODO remove */
    background-position: center;

    /* --- General Button Styles --- */
    width: 100%;
    height: 100%;
    border: none;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    cursor: pointer;
    transition: opacity 0.3s;
    display: flex;
    justify-content: center;
    align-items: center;
    /* 
    background: linear-gradient(135deg, #ff7e5f, #feb47b);
				color: white;
				border: none;
				padding: 10px 20px;
				font-size: 1rem;
				font-weight: bold;
				border-radius: 25px;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
				transition: transform 0.2s, box-shadow 0.2s;
    
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #ff7e5f, #feb47b);
    color: white;
    border: none;
    padding: 12px 24px;
    font-size: 1rem;
    font-weight: bold;
    border-radius: 25px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s, box-shadow 0.2s;
    cursor: pointer; */
  }

  /* This keeps child nodes hidden while the element loads, except the poster */
	/* 		:not(:defined) > :not(.poster) {
				display: none;
			}
			:defined > .poster > .pre-prompt {
				display: none;
			} 

      @keyframes wiggle {	
				10%, 12% { transform: translateX(-25px); }	 
				30%, 32% { transform: translateX(25px); }	
				0%, 45%, 100% { transform: translateX(0%); }
			}	
			@keyframes fade {	
				5%, 40% { opacity: 1; }	
				0%, 45%, 100% {	opacity: 0; }	 
			}
        
     .pre-prompt {
				pointer-events: none;
				animation-name: wiggle, fade;
				animation-duration: 5s;
				animation-iteration-count: infinite;
				animation-timing-function: ease-in-out;

       

        .loadButton:active {
				transform: scale(0.95);
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			}

        */
        


  .poster-button:hover {
    opacity: 0.9;
    /* cursor: pointer; */
    /* transform: translate(-50%, -50%) scale(1.05); */
    /* box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15); */
  }

  .poster-button .button-text {
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 12px 24px;
    border-radius: 25px;
    font-size: 1.2rem;
    font-weight: bold;
    backdrop-filter: blur(5px);
  }

  .error-message {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #333;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 8px;
        pointer-events: none;
    }

  .progress-bar {
    display: block;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate3d(-50%, -50%, 0);
    width: 33%;
    height: 16px;
    max-height: 2%;
    box-shadow: 0px 3px 10px 3px rgba(0, 0, 0, 0.5), 0px 0px 5px 1px rgba(0, 0, 0, 0.6);
		border: 1px solid rgba(255, 255, 255, 0.9);
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 20px;
    overflow: hidden;
    /* transition: visibility 0s linear 0.3s; */
  }

  .update-bar {
    width: 0%;
    height: 100%;
    background-color: var(--mv-progress-bar-color); /* background-color: rgba(255, 255, 255, 0.9); */
    border-radius: 8px;
    transition: width 0.3s ease-out;
  }

  .hide { display: none !important; } /*  Previously visibility:hidden for progress-bar and loadButtonCOntainer (now removed)  */
</style>